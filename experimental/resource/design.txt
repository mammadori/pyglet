Resource (image, font, sound) loading for pyglet.  

Features:

* resources are named by their filename
* resources can be packed into a directory (boring), a python package (aha,
  examples/*.py boilerplate removal), a zip (useful)
* multiple resource locations can be specified intially, facilitating
  "override" directories (for modding and debugging and monkeypatching)
* should ideally also work nicely with py2exe (resources either inside exe
  or library.zip), py2app (resources inside bundle) and eggs (shudder --
  hopefully also without using pkg_resources).

* (heuristically) small images are packed onto single, larger textures
* images can be loaded with optional 90-degree rotation or flip (tex coord
  manipulation) -- the same image loaded twice at different rotations uses
  a single texture
* it should be straightforward to view the current textures that have been
  allocated (for debugging, to see how images are being packed).

Anti-features:

* fonts will still need to be loaded by filename but then used by family name,
  there's no nice way around this (except on windows).
* compressed audio and video won't be loadable from zips, this requires more
  code in AVbin which is not a priority atm. (and extracting to a temp file
  would be weird and ugly).

Module usage::

    from pyglet import resource

    resource.path = [
        'res/images',               # Filesystem directories
        'res/sounds',
        '.',
        'resources.zip',            # ZIP files
        'resources.zip/images',     # Directories within ZIP
        '@widget.skins.marble',     # Python packages
    ]

    # Load an image (returns a TextureRegion)
    car = resource.image('car.png')
    car_backwards = resource.image('car.png', flip_x=True)
    car_sideways = resource.image('car.png', rotate=90) # clockwise

    # Preload some images (they will be packed optimally)
    resource.preload_images('car.png', 'bike.png', 'boss.png')

    # Preload all images in resource path (more useful than you think... see
    # below):
    resource.preload_images()

    # Load a texture (returns a Texture or CompressedTexture, does not pack)
    # intended for 3D usage or other places where you know what you're doing
    marble = resource.texture('marble.png')

    # Load a media source (returns a Source; streaming as for media.load)
    # Media sources are not cached.
    explosion = resource.media('explosion.wav', streaming=False)

    # Load a font (returns nothing, same as font.add_font).
    resource.preload_font('action_man.ttf')
    resource.preload_font('action_man.ttf', bold=True)

    # Load all fonts that are in the resource path
    resource.preload_fonts()

    # Open a file using the same resource search path
    story = resource.file('story.txt')

    # Can also write files.  If file is not found anywhere, created in first
    # writeable directory on path.  If file is found in a read-only path (e.g.
    # a ZIP file), exception is raised.
    hs = resource.file('highscores.txt', 'wt')

Multiple loader usage::

    # Create an isolated resource loader
    level1_res = resource.Loader('level1')

    # The Loader object supports all the methods shown above on the module
    # (which really just match to some default unseen Loader).
    level1_res.preload_images()

    # This might be handy for loading screens:
    for progress in level1_res.preload_images_iter():
        print progress # in range 0.0 to 1.0

Manual control over texture packing::

    atlas = resource.TextureAtlas(256, 256)
    
    # Raises exception if it doesn't fit into that atlas
    car = resource.image('car.png', atlas=atlas)

    # If you're going to be needing interpolation:
    car = resource.image('car.png', pad=2) # 2 pixel border of (0,0,0,0)

Debug methods::

    resource.get_texture_atlases()                # list of Texture
    resource.get_texture_atlas_usage()            # in range 0.0 to 1.0
    resource.get_texture_atlas_fragmentation()    # in range 0.0 to 1.0
    resource.get_cached_image_names()             # list of str

Unresolved:

* What's the default path? (I suggest ['.', '@%s' % __main__])
* How are paths expected to reside within py2exe exe or py2app resource
  specified (to disambiguate from file-system paths); or do we only allow
  this magic when those resources are inside a python package? (would mean
  resource dirs would need __init__.py.. bit weird).
  - py2exe doesn't really provide a way to include bulk data inside the 
    executable; developers will provide assets alongside the executable
    in the same directory (or subdirectory).
  - py2app always changes the working dir to RESOURCEPATH (the Resources dir
    inside the bundle) before starting the main script, so this is where
    assets go.
  - so (for py2exe and possible py2app hacks) it would be best to allow
    a simple way to specify assets relative to the script dir (not the working
    dir).  w/ py2exe the script dir is the exe's dir.  w/ py2app the script
    dir is the Resource dir.
* Hey, wouldn't warnings for case-mismatches on case-insensitive filesystems 
  be a honking great idea?
  - in my implementation so far these will generate an file-not-found error,
    not a case warning.. to me this seems just as good, and will probably 
    get the problem fixed faster anyway.
* How about something to help / guide prepending a save/override path to
  the front of a path::

	'~/mycoolgame'				# if sys.platform in ('win32', 'cygwin')
	'~/Library/mycoolgame'		# if sys.platform == 'darwin'
	'~/.mycoolgame'				# otherwise

Path specification:

We want to support the following base directories:

* Script dir
* User application settings dir

Because resource module is only for loading assets, not general files, there's
no need to support the working dir or the user's home directory.  Also no need
for absolute paths, but I guess there's no point preventing them (maybe an app
will want to store absolute paths somewhere else such as the windows registry
and then use those paths with resource module).

How about:

* 'foo/bar' (relative path) uses script dir as base
* '/foo/bar' or 'c:\\foo\\bar' (absolute path) is absolute
* '@foo.bar' is a Python package
* resource.get_settings_path('mycoolgame') returns an absolute path to the
  game-specific settings dir and creates it if it doesn't exist
* backslashes are disallowed except in absolute paths.
