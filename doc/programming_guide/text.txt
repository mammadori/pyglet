Displaying text
===============

pyglet provides the `font` module for rendering high-quality antialiased
Unicode glyphs efficiently.  Any installed font on the operating system can be
used, or you can supply your own font with your application.  

Text rendering is performed with the `text` module, which can display
word-wrapped formatted text.  There is also support for interactive editing of
text on-screen with a caret.

.. contents::
    :local:

Simple text rendering
---------------------

The following complete example creates a window that displays "Hello, World" 
centered vertically and horizontally::

    window = pyglet.window.Window()
    label = pyglet.text.Label('Hello, world', 
                              font_name='Times New Roman', 
                              font_size=36,
                              x=window.width//2, y=window.height//2,
                              anchor_x='center', anchor_y='center')

    @window.event
    def on_draw():
        window.clear()
        label.draw()

    pyglet.app.run() 

The example demonstrates the most common uses of text rendering:

* The font name and size are specified directly in the constructor.
  Additional parameters exist for setting the bold and italic styles and the
  color of the text.
* The position of the text is given by the ``x`` and ``y`` coordinates.  The
  meaning of these coordinates is given by the ``anchor_x`` and ``anchor_y``
  parameters.
* The actual text is drawn with the `Label.draw` method.  Labels can also be
  added to a graphics batch; see `Graphics` for details.

The `HTMLLabel` class is used similarly, but accepts an HTML formatted string
instead of parameters describing the style.  This allows the label to display
text with mixed style::

    label = pyglet.text.HTMLLabel(
        '<font face="Times New Roman" size="4">Hello, <i>world</i></font>',
        x=window.width//2, y=window.height//2,
        anchor_x='center', anchor_y='center')

See `Formatted text` for details on the subset of HTML that is supported.

The document/layout model
-------------------------

The `Label` class demonstrated above presents a simplified interface to
pyglet's complete text rendering capabilities.  The underlying `TextLayout`
and `AbstractDocument` classes provide a "model/view" interface to all of
pyglet's text features.

    .. image:: layout-classes.svg

Documents
^^^^^^^^^

A `document` is the "model" part of the architecture, and describes the
content and style of the text to be displayed.  There are two concrete
document classes: `UnformattedDocument` and `FormattedDocument`.
`UnformattedDocument` models a document containing text in just one style,
whereas `FormattedDocument` allows the style to change within the text.

An empty, unstyled document can be created by constructing either of the
classes directly.  Usually you will want to initialise the document with some
text, however.  The `decode_text`, `decode_attributed` and `decode_html`
functions return a document given a source string.  For `decode_text`, this is
simply a plain text string, and the return value is an `UnformattedDocument`::

    document = pyglet.text.decode_text('Hello, world.')

`decode_attributed` and `decode_html` are described in detail in the next
section.

The text of a document can be modified directly as a property on the object::

    document.text = 'Goodbye, cruel world.')

However, if small changes are being made to the document it can be more
efficient (when coupled with an appropriate layout; see below) to use the
`remove_text` and `insert_text` methods instead.

Layouts
^^^^^^^

The actual layout and rendering of a document is performed by the `TextLayout`
classes.  This split exists to reduce the complexity of the code, and to allow
a single document to be displayed in multiple layouts simultaneously (in other
words, many layouts can display one document).

Each of the `TextLayout` classes perform layout in the same way, but represent
a trade-off in efficiency of update against efficiency of drawing and memory
usage.

The base `TextLayout` class uses little memory, and shares its graphics
group with other `TextLayout` instances in the same batch (see `Batched
rendering`).  When the text or style of the document is modified, or the
layout constraints change (for example, the width of the layout changes), the
entire text layout is recalculated.  This is a potentially expensive
operation, especially for long documents.  This makes `TextLayout` suitable
for relatively short or unchanging documents.

`ScrollableTextLayout` is a small extension to `TextLayout` that clips the
text to a specified view rectangle, and allows text to be scrolled within that
rectangle without performing the layout calculuation again.  Because of this
clipping rectangle the graphics group cannot be shared with other text
layouts, so for ideal performance `ScrollableTextLayout` should be used only
if this behaviour is required.

`IncrementalTextLayout` uses a more sophisticated layout algorithm that
performs less work for small changes to documents.  For example, if a document
is being edited by the user, only the immediately affected lines of text are
recalculated when a character is typed or deleted.  `IncrementalTextLayout`
also performs view rectangle culling, reducing the amount of layout and
rendering required when the document is larger than the view.
`IncrementalTextLayout` should be used for large documents or documents that
change rapidly.

All the layout classes can be constructed given a document and display
dimensions::

    layout = pyglet.text.TextLayout(document, width, height)

Additional arguments to the constructor allow the specification of a graphics
batch and group (recommended if many layouts are to be rendered), and the
optional `multiline` flag.  To render more than one line of text (either
through word-wrapping or explicit line breaks) `multiline` must be ``True``.

Like labels, layouts are positioned through their `x`, `y`, `anchor_x` and
`anchor_y` properties.  Note that unlike `AbstractImage`, the `anchor`
properties accept a string such as ``"bottom"`` or ``"center"`` instead of a
numeric displacement.

Formatted text
--------------

HTML

Attributed text

Custom elements


User-editable text
------------------

Incremental

Caret, selection

Loading system fonts
--------------------

..
    XXX TODO separate from layout stuff above

To load a font you must know its family name.  This is the name displayed in
the font dialog of any application.  For example, all operating systems
include the *Times New Roman* font.  You must also specify the font size to
load, in points::

    # Load "Times New Roman" at 16pt
    times = pyglet.font.load('Times New Roman', 16)

Bold and italic variants of the font can specified with keyword parameters::

    times_bold = pyglet.font.load('Times New Roman', 16, bold=True)
    times_italic = pyglet.font.load('Times New Roman', 16, italic=True)
    times_bold_italic = pyglet.font.load('Times New Roman', 16, 
                                         bold=True, italic=True)

For maximum compatibility on all platforms, you can specify a list of font
names to load, in order of preference.  For example, many users will have
installed the Microsoft Web Fonts pack, which includes `Verdana`, but this
cannot be guaranteed, so you might specify `Arial` or `Helvetica` as
suitable alternatives::

    sans_serif = pyglet.font.load(('Verdana', 'Helvetica', 'Arial'), 16)

If you do not particularly care which font is used, and just need to display
some readable text, you can specify `None` as the family name, which will load
a default sans-serif font (Helvetica on Mac OS X, Arial on Windows XP)::

    sans_serif = pyglet.font.load(None, 16)

Font sizes
----------

When loading a font you must specify the font size it is to be rendered at, in
points.  Points are a somewhat historical but conventional unit used in both
display and print media.  There are various conflicting definitions for the
actual length of a point, but pyglet uses the PostScript definition: 1 point =
1/72 inches.

Font resolution
^^^^^^^^^^^^^^^

The actual rendered size of the font on screen depends on the display
resolution. pyglet uses a default DPI of 96 on all operating systems.  Most
Mac OS X applications use a DPI of 72, so the font sizes will not match up on
that operating system.  However, application developers can be assured that
font sizes remain consistent in pyglet across platforms.

The DPI can be specified directly in the `pyglet.font.load` function.

Determining font size
^^^^^^^^^^^^^^^^^^^^^

.. 
    TODO XXX make relevant to layout

Once a font is loaded at a particular size, you can query its pixel size with
the attributes::

    Font.ascent
    Font.descent

These measurements are shown in the diagram below.

.. figure:: font_metrics.svg
    
    Font metrics.  Note that the descent is usually negative as it descends
    below the baseline.

You can calculate the distance between successive lines of text as::

    ascent - descent + leading

where `leading` is the number of pixels to insert between each line of text.

Loading custom fonts
--------------------

..
    XXX TODO change examples to use Label

You can supply a font with your application if it's not commonly installed on
the target platform.  You should ensure you have a license to distribute the
font -- the terms are often specified within the font file itself, and can be
viewed with your operating system's font viewer.

Loading a custom font must be performed in two steps:

1. Let pyglet know about the additional font or font files.
2. Load the font by its family name.

For example, let's say you have the *Action Man* font in a file called
``action_man.ttf``.  The following code will load an instance of that font::

    pyglet.font.add_file('action_man.ttf')
    action_man = pyglet.font.load('Action Man')

Fonts are often distributed in separate files for each variant.  *Action Man
Bold* would probably be distributed as a separate file called
``action_man_bold.ttf``; you need to let pyglet know about this as well::

    font.add_file('action_man_bold.ttf')
    action_man_bold = font.load('Action Man', bold=True)

Note that even when you know the filename of the font you want to load, you
must specify the font's family name to `pyglet.font.load`.

You need not have the file on disk to add it to pyglet; you can specify any
file-like object supporting the `read` method.  This can be useful for
extracting fonts from a resource archive or over a network.

If the custom font is distributed with your application, consider using the
`Application resources`.

Supported font formats
^^^^^^^^^^^^^^^^^^^^^^

pyglet can load any font file that the operating system natively supports.
The list of supported formats is shown in the table below.

    .. list-table::
        :header-rows: 1

        * - Font Format
          - Windows XP
          - Mac OS X
          - Linux (FreeType)
        * - TrueType (.ttf)
          - X
          - X
          - X
        * - PostScript Type 1 (.pfm, .pfb)
          - X
          - X
          - X
        * - Windows Bitmap (.fnt)
          - X
          - 
          - X
        * - Mac OS X Data Fork Font (.dfont)
          - 
          - X 
          - 
        * - OpenType (.ttf) [#opentype]_
          -
          - X
          -
        * - X11 font formats PCF, BDF, SFONT
          -
          - 
          - X
        * - Bitstream PFR (.pfr)
          -
          -
          - X

.. [#opentype] All OpenType fonts are backward compatible with TrueType, so
               while the advanced OpenType features can only be rendered with
               Mac OS X, the files can be used on any platform.  pyglet
               does not currently make use of the additional kerning and
               ligature information within OpenType fonts.

OpenGL font considerations
--------------------------

..
    TODO XXX N/A for layout?

Text in pyglet is drawn using textured quads.  Each font maintains a set of
one or more textures, into which glyphs are uploaded as they are needed.  For
most applications this detail is transparent and unimportant, however some of
the details of these glyph textures are described below for advanced users.

Context affinity
^^^^^^^^^^^^^^^^

..
    TODO XXX When is a font loaded

When a font is loaded, it immediately creates a texture in the current
context's object space.  Subsequent textures may need to be created if there
is not enough room on the first texture for all the glyphs.  This is done when
the glyph is first requested.  

pyglet always assumes that the object space that was active when the font was
loaded is the active one when any texture operations are performed.  Normally
this assumption is valid, as pyglet shares object spaces between all contexts
by default.  There are a few situations in which this will not be the case,
though:

* When explicitly setting the context share during context creation.
* When multiple display devices are being used which cannot support a shared
  context object space.

In any of these cases, you will need to reload the font for each object space
that it's needed in.  pyglet keeps a cache of fonts, but does so
per-object-space, so it knows when it can reuse an existing font instance or
if it needs to load it and create new textures.  You will also need to ensure
that an appropriate context is active when any glyphs may need to be added.

Blend state
^^^^^^^^^^^

The glyph textures have an internal format of ``GL_ALPHA``, which provides
a simple way to recolour and blend antialiased text by changing the
vertex colors.  pyglet makes very few assumptions about the OpenGL state, and
will not alter it besides changing the currently bound texture.

The following blend state is used for drawing font glyphs::

    from pyglet.gl import *
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
    glEnable(GL_BLEND)

All glyph textures use the ``GL_TEXTURE_2D`` target, so you should ensure that
a higher priority target such as ``GL_TEXTURE_3D`` is not enabled before
trying to render text.
